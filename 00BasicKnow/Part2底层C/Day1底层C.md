# Day3:底层C

## 0x0 前言

​	首先，学个C语言，这个C语言并非我们通常使用的C语言，虽然C语言的外表都是一样的，但是学了这么多次C语言(因为本人学艺不精以及错误的方法，所以反反复复学了很多次C语言)，最终找到了一种方式，让我真正感觉到了C语言的魅力。

​	**那就是和底层链接起来。**

​	众所周知，Windows系统当初都是用C语言编写的，大多API接口也是一样，那么如果我们自己用C来写API接口和计算机通话呢？但是吧，这个难度也是比较大了，仅作一个idea，但是放到底层的C，我认为是计算机的灵魂！

## 1x0 C运行的原理

​	抛个问题：代码怎么跑起来的？为什么写了一个printf，就打印到了屏幕上？	

​	随着年龄的增长，我越来越没有了对事物的好奇心，也就使得对很多东西都不感兴趣。也事倍功半，总之，处于一个多学少成的状态。

​	看个图片：

​	![image-20251113162908651](C:\Users\21543\AppData\Roaming\Typora\typora-user-images\image-20251113162908651.png)

解释：

- C代码经过预处理、编译、链接，最后组成了可执行文件，编译器和链接器确定各段的位置和大小，操作系统将这些段放入物理内存中，但是使用虚拟内存来管理(这涉及到OS的虚拟内存管理的知识)。
- C程序加载到内存，操作系统为其创建虚拟地址空间，C程序在执行读写代码时，其实并不是直接读取内存中的地址，而是这个虚拟地址空间中的地址。（例如取值操作，访问的是虚拟地址，但是值保存在物理地址）
- 那么读写虚拟地址如何能作用到内存中的物理地址呢？CPU有一个内存管理单元MMU，用于将虚拟地址转换为物理内存地址，其中有个CR3寄存器，会查询页表的物理地址，页表的作用？把虚拟内存空间映射到物理内存。
- 最后，CPU找到了代码所在的物理地址并取值，实现了内存访问。



- 总体的作用如下：
- **C程序编译链接** → 确定各段虚拟地址。
- **程序加载** → 操作系统创建虚拟地址空间，并加载段到内存（虚拟地址）。
- **内存访问** → 程序读写虚拟地址。
- **地址转换** → MMU使用CR3和页表将虚拟地址转换为物理地址。
- **物理内存访问** → CPU访问物理地址，返回数据。
- **页错误处理** → 如果页面缺失，操作系统介入，分配页帧并更新页表。
- 而这些最终是为了实现C程序对物理内存的透明访问。

## 2x0 C基础

这个基础呢，我真的是学了很多遍了，所以我不想写基础的。哈哈哈

主要写字符串处理、内存管理、文件操作、指针、链表、队列。



